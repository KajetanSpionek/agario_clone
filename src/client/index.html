<!DOCTYPE html>
<html lang="en">
<head>
<meta charset=utf-8>
<title>Agar.io</title>
<link rel="stylesheet" type="text/css" href="./css/simple_css.css">
</head>
<body>
<section id="wrapper">

      <h1>Agar.io</h1>


 <div id="left">
    <canvas id="myCanvas" style="border:4px solid black;" width="800" height="800"> </canvas>
    <p> Current status: <span id="status">Not connected</span></p>
    <p>Users connected: <span id="connected">0</span></p>
 </div>


<div id="right">
  <article>
  	<h1> Info </h1>
  	<p> Xpos: <span id="x_pos">Not connected</span></p>
  	<p> Ypos: <span id="y_pos">Not connected</span></p>
  	<p> Mass (radius): <span id="mass_pos">Not connected</span></p>
    <h1> Recived data </h1>
    <ul id="log"></ul>
  </article>
</div>


 <script src="js/connection.js"></script> 
 <script src="js/ball.js"></script> 
 <script src="js/player.js"></script> 
 <script src="js/food.js"></script> 


<script>
    
    var x_pos_state = document.getElementById("x_pos");
    var y_pos_state = document.getElementById("y_pos");
    var mass_state = document.getElementById("mass_pos");

    var canvas = document.getElementById('myCanvas');
    var context = canvas.getContext('2d');
    
    var raf;

    var maximalUpdateDelay = 25; // ms
	var updateTimeout, now;


    var foods = [];
    var player = -1;
    var balls = [];
    var mousePos;

    var boardMargin = 0;

    var gameBoardX;
    var gameBoardY;

    var deltaX;
    var deltaY;
    
    var scl = 1;
    var send_interval = 1;
    var send_interval_period = 2;
    
    
    function getRandomColor() 
    {
        var letters = '0123456789ABCDEF';
        var color = '#';
        for (var i = 0; i < 6; i++ ) {
            color += letters[Math.floor(Math.random() * 16)];
        }
        return color;
    }
    
    function drawCircle(x_center,y_center,radius,color)
    {
		context.strokeStyle = 'black';
        var start_angle = 0;
        var end_angle = 2*Math.PI;
        context.beginPath();    
        context.arc(x_center-deltaX,y_center-deltaY,scl*radius,start_angle,end_angle);
		context.fillStyle = color;
        context.fill();
        context.lineWidth = 2;
        context.stroke();
    }

    function drawCircleFx(fx_center,fy_center,radius,color)
   {
		context.strokeStyle = 'black';
        var start_angle = 0;
        var end_angle = 2*Math.PI;
        context.beginPath();    
        context.arc(player.x_+fx_center-deltaX,player.y_+fy_center-deltaY,scl*radius,start_angle,end_angle);
		context.fillStyle = color;
        context.fill();
        context.lineWidth = 2;
        context.stroke();
   }
    
    function onError(evt)
    { 
        state.className = "fail";
        state.innerHTML = "Communication error";
    }  

    function gameLoop() {

        raf = window.requestAnimationFrame(update);

    }

function getMousePos(canvas, evt) {
        var rect = canvas.getBoundingClientRect();
        return {
          x: evt.clientX - rect.left,
          y: evt.clientY - rect.top
        };
}

canvas.addEventListener('mousemove', function(evt) {
        mousePos = getMousePos(canvas, evt);
});

canvas.addEventListener('mouseover', function(e) {
  	raf = window.requestAnimationFrame(update);
});


canvas.addEventListener('mouseout', function(e) {
  window.cancelAnimationFrame(raf);
});

function reDrawCanvas() {

	

	for (var i in foods) {
		calculateFixedPos();
		foods[i].show();
	}

	

	for (var i in balls)
		balls[i].show();

	player.show();
}

function reDrawGrid() {

context.fillStyle = '#F0FBFF';
context.strokeStyle = '#BFBFBF';
context.lineWidth = 1;
constY = 50*scl - ((deltaY + 399) % 50*scl);
constX = 50*scl - ((deltaX + 399) % 50*scl);

//log.innerHTML = '<li class="message">' + deltaX + "</li>" + log.innerHTML;


for (i=0; i < 800; i += 50*scl) {
	context.beginPath();
   	context.moveTo(0,constY + i);
   	context.lineTo(800,constY + i);
   	context.stroke();
 }


for (i=0; i < 800; i += 50*scl) {
	context.beginPath();
  	context.moveTo(constX + i,0);
   	context.lineTo(constX + i,800);
   	context.stroke();
}

context.lineWidth = 3;
context.strokeStyle = 'black';
context.beginPath();
context.moveTo(- deltaX,- deltaY);
context.lineTo(- deltaX + gameBoardX,- deltaY);
context.stroke();

context.beginPath();
context.moveTo(- deltaX,- deltaY);
context.lineTo(- deltaX,- deltaY + gameBoardY);
context.stroke();

context.beginPath();
context.moveTo(- deltaX + gameBoardX,- deltaY);
context.lineTo(- deltaX + gameBoardX,- deltaY + gameBoardY);
context.stroke();

context.beginPath();
context.moveTo(- deltaX,- deltaY + gameBoardY);
context.lineTo(- deltaX + gameBoardX,- deltaY + gameBoardY);
context.stroke();


}

function update() {
 
	// New movement 

	var dx = mousePos.x - 399;
  	var dy = mousePos.y - 399;
  	var v_len = Math.abs(Math.sqrt( (dy*dy) + (dx*dx) ));

  	var scaleX = Math.abs(dx / v_len);
  	var scaleY = Math.abs(dy / v_len);

  	

  	if (mousePos.x > 400 && player.x_ < gameBoardX - boardMargin) {
  		deltaX += scaleX *player.vx_;
  		player.x_ += scaleX * player.vx_;
  	}
  	else if (mousePos.x < 400 && player.x_ > 0 + boardMargin) {
  		deltaX -= scaleX * player.vx_;
  		player.x_ -= scaleX * player.vx_;
  	}
  	else {
		deltaX = deltaX;
  		player.x_ = player.x_;

  	}

  	if (mousePos.y > 400 && player.y_ < gameBoardY - boardMargin) {
  		deltaY += scaleY * player.vy_;
  		player.y_ += scaleY * player.vy_;

  	}
  	else if (mousePos.y < 400 && player.y_ > 0 + boardMargin) {
  		deltaY -= scaleY * player.vy_;
  		player.y_ -= scaleY * player.vy_;
  	}
  	else {
		deltaY = deltaY;
  		player.y_ = player.y_;

  	}

  	scl = 1 - (player.r_ / 500);
  	if (scl < 0.2) scl = 0.2;

	context.clearRect(0,0,800,800);
	reDrawGrid();
	reDrawCanvas();
	sendPos();
	raf = window.requestAnimationFrame(update);
     
    
}


window.requestAnimFrame = (function() {
    return  window.requestAnimationFrame       ||
            window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame    ||
            window.msRequestAnimationFrame     ||
            function( callback ) {
                window.setTimeout(callback, 1000 / 60);
            };
})();

window.cancelAnimFrame = (function(handle) {
    return  window.cancelAnimationFrame     ||
            window.mozCancelAnimationFrame;
})();

function calculateFixedPos() {

	for (var i in foods) {

		foods[i].fx_ = (foods[i].x_ - player.x_)*scl;
		foods[i].fy_ = (foods[i].y_ - player.y_)*scl;
	}

	for (var i in balls) {

		balls[i].fx_ = (balls[i].x_ - player.x_)*scl;
		balls[i].fy_ = (balls[i].y_ - player.y_)*scl;
	}
}

function gameOver() {

	balls = [];
	foods = [];
	player = [];
	reDrawGrid();
	reDrawCanvas();
}










 
</script>
</section>
</body>
</html>
