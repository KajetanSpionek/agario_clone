<!DOCTYPE html>
<html lang="en">
<head>
<meta charset=utf-8>
<title>Agar.io</title>
<link rel="stylesheet" type="text/css" href="./css/simple_css.css">
</head>
<body>
<section id="wrapper">

      <h1>Agar.io</h1>


 <div id="left">
    <canvas id="myCanvas" style="border:4px solid black;" width="800" height="800"> </canvas>
    <p> Current status: <span id="status">Not connected</span></p>
    <p>Users connected: <span id="connected">0</span></p>
 </div>


<div id="right">
  <article>
  	<h1> Some data </h1>
  	<p> Xpos: <span id="x_pos">Not connected</span></p>
  	<p> Ypos: <span id="y_pos">Not connected</span></p>
  	<p> Mass (radius): <span id="mass_pos">Not connected</span></p>
    <h1> Recived data </h1>
    <ul id="log"></ul>
  </article>
</div>


 <script src="js/connection.js"></script> 
 <script src="js/ball.js"></script> 
 <script src="js/player.js"></script> 
 <script src="js/food.js"></script> 


<script>
    
    x_pos_state = document.getElementById("x_pos");
    y_pos_state = document.getElementById("y_pos");
    mass_state = document.getElementById("mass_pos");

    var canvas = document.getElementById('myCanvas');
    var context = canvas.getContext('2d');
    
    var raf;

    var maximalUpdateDelay = 25; // ms
	var updateTimeout, now;


    var foods = [];
    var player = -1;
    var balls = [];
    var mousePos;

    var boardMargin = 5;

    var gameBoardX;
    var gameBoardY;

    var deltaX;
    var deltaY;
    
    
    
    function getRandomColor() 
    {
        var letters = '0123456789ABCDEF';
        var color = '#';
        for (var i = 0; i < 6; i++ ) {
            color += letters[Math.floor(Math.random() * 16)];
        }
        return color;
    }
    
    function drawCircle(x_center,y_center,radius,color)
    {
        var start_angle = 0;
        var end_angle = 2*Math.PI;
        var c = document.getElementById("myCanvas");
        var ctx = c.getContext("2d");
        ctx.beginPath();    
        ctx.arc(x_center-deltaX,y_center-deltaY,radius,start_angle,end_angle);
		ctx.fillStyle = color;
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.stroke();
    }
    
    function onError(evt)
    { 
        state.className = "fail";
        state.innerHTML = "Communication error";
    }  

    function gameLoop() {

        raf = window.requestAnimationFrame(update);

    }

function getMousePos(canvas, evt) {
        var rect = canvas.getBoundingClientRect();
        return {
          x: evt.clientX - rect.left,
          y: evt.clientY - rect.top
        };
}

canvas.addEventListener('mousemove', function(evt) {
        mousePos = getMousePos(canvas, evt);
});

canvas.addEventListener('mouseover', function(e) {
  	raf = window.requestAnimationFrame(update);
});


canvas.addEventListener('mouseout', function(e) {
  window.cancelAnimationFrame(raf);
});

function reDrawCanvas() {

	

	for (var i in foods) {
		foods[i].show();
	}

	player.show();

	for (var i in balls)
		balls[i].show();

}

function reDrawGrid() {

context.fillStyle = "#F0FBFF";
context.strokeStyle = "BFBFBF";
context.lineWidth = 1;
constY = 150 - ((deltaY + 399) % 150);
constX = 150 - ((deltaX + 399) % 150);

//log.innerHTML = '<li class="message">' + deltaX + "</li>" + log.innerHTML;


for (i=0; i < 800; i += 150) {
	context.beginPath();
   	context.moveTo(0,constY + i);
   	context.lineTo(800,constY + i);
   	context.stroke();
 }


for (i=0; i < 800; i += 150) {
	context.beginPath();
  	context.moveTo(constX + i,0);
   	context.lineTo(constX + i,800);
   	context.stroke();
}


}

function update() {
 
	// New movement 

	var dx = mousePos.x - 399;
  	var dy = mousePos.y - 399;
  	var v_len = Math.abs(Math.sqrt( (dy*dy) + (dx*dx) ));

  	var scaleX = Math.abs(dx / v_len);
  	var scaleY = Math.abs(dy / v_len);

  	

  	if (mousePos.x > 400 && player.x_ < gameBoardX - boardMargin ) {
  		deltaX += scaleX *player.vx_;
  		player.x_ += scaleX * player.vx_;
  	}
  	else if (mousePos.x < 400 && player.x_ > 0 + boardMargin) {
  		deltaX -= scaleX * player.vx_;
  		player.x_ -= scaleX * player.vx_;
  	}
  	else {
		deltaX = deltaX;
  		player.x_ = player.x_;

  	}

  	if (mousePos.y > 400 && player.y_ < gameBoardY - boardMargin) {
  		deltaY += scaleY * player.vy_;
  		player.y_ += scaleY * player.vy_;

  	}
  	else if (mousePos.y < 400 && player.y_ > 0 + boardMargin) {
  		deltaY -= scaleY * player.vy_;
  		player.y_ -= scaleY * player.vy_;
  	}
  	else {
		deltaY = deltaY;
  		player.y_ = player.y_;

  	}

	context.clearRect(0,0,800,800);
	reDrawGrid();
	reDrawCanvas();
	sendPos();
	raf = window.requestAnimationFrame(update);
     
    
}


window.requestAnimFrame = (function() {
    return  window.requestAnimationFrame       ||
            window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame    ||
            window.msRequestAnimationFrame     ||
            function( callback ) {
                window.setTimeout(callback, 1000 / 60);
            };
})();

window.cancelAnimFrame = (function(handle) {
    return  window.cancelAnimationFrame     ||
            window.mozCancelAnimationFrame;
})();





















    
</script>
</section>
</body>
</html>
