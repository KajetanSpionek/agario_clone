<!DOCTYPE html>
<html lang="en">
<head>
<meta charset=utf-8>
<title>Agar.io</title>
<link rel="stylesheet" type="text/css" href="simple_css.css">
</head>
<body>
<section id="wrapper">

      <h1>Agar.io</h1>


 <div id="left">
    <canvas id="myCanvas" style="border:4px solid black;" width="800" height="800"> </canvas>
    <p> Current status: <span id="status">Not connected</span></p>
    <p>Users connected: <span id="connected">0</span></p>
 </div>


<div id="right">
  <article>
    <h1> Recived data </h1>
    <ul id="log"></ul>
  </article>
</div>


 
 <script src="app.js"></script> 

<script>
    

    connected = document.getElementById("connected");
    log = document.getElementById("log");
    state = document.getElementById("status");
    var canvas = document.getElementById('myCanvas');
    var context = canvas.getContext('2d');
    
    var raf;

    var maximalUpdateDelay = 25; // ms
	var updateTimeout, now;


    var foods = [];
    var player = -1;
    var players = [];
    var mousePos;

    var boardMargin = 5;

    var gameBoardX;
    var gameBoardY;

    var deltaX;
    var deltaY;
    
    if (window.WebSocket === undefined)
    {
        state.innerHTML = "sockets not supported";
        state.className = "fail";
    }
    else
    {
        if (typeof String.prototype.startsWith != "function")
        {
            String.prototype.startsWith = function (str)
            {
                return this.indexOf(str) == 0;
            };
        }
    
        window.addEventListener("load", onLoad, false);
    }

    function onLoad()
    {
        var wsUri = "ws://127.0.0.1:7777";  
    
        websocket = new WebSocket(wsUri);
        websocket.onopen = function(evt) { onOpen(evt) };
        websocket.onclose = function(evt) { onClose(evt) };
        websocket.onmessage = function(evt) { onMessage(evt) };
        websocket.onerror = function(evt) { onError(evt) };
    }
  
    function onOpen(evt)
    {
        state.className = "success";
        state.innerHTML = "Connected to server";    
    }
  
    function onClose(evt)
    {
        state.className = "fail";
        state.innerHTML = "Not connected";
        connected.innerHTML = "0";        
    }
  
    function onMessage(evt)
    {
        // There are two types of messages: 
        //     1. a chat participant message itself
        //     2. a message with a number of connected chat participants
  
        var message = evt.data;
    
        if (message.startsWith("log:")) {
            message = message.slice("log:".length);
            log.innerHTML = '<li class="message">' + message + "</li>" + log.innerHTML; 
        }
        else if (message.startsWith("connected:")) {
            message = message.slice("connected:".length);
            connected.innerHTML = message;  
        }   

        else if (message.startsWith("newFood:")) {
            message = message.slice("newFood:,".length);
            message = message.split(" ");
            log.innerHTML = '<li class="message">' + "newFood:" + message + "</li>" + log.innerHTML; 

            if (foods.indexOf(message[0]) == -1) {

                    var len = foods.length;
                    var color = getRandomColor();
                    foods[len] = new Food(parseInt(message[0]),parseInt(message[1]), parseInt(message[2]), color);
                    foods[len].show(); //Display ball
                }
            

        }
        
        else if (message.startsWith("newBall:")) {
            message = message.slice("newBall:,".length);
            message = message.split(" ");
            log.innerHTML = '<li class="message">' + "newBall:" + message + "</li>" + log.innerHTML;

            if (players.indexOf(message[0]) == -1 && player.id != message[0]) {

                    var len = players.length;
                    players[len] = new Player(parseInt(message[0]),parseInt(message[1]), parseInt(message[2]), parseInt(message[3]),message[4]);
                    players[len].show(); //Display player
                }
  
        } 

        else if (message.startsWith("gameStateBall")) {
            message = message.slice("gameStateBall:,".length);
            message = message.split(" ");
            log.innerHTML = '<li class="message">' + "gameStateBall:" + message + "</li>" + log.innerHTML;
            if (message.length > 4 ) {
            	for( i = 0; i < message.length; i+=5){
                	if (players.indexOf(message[i]) == -1) { 
                    	var len = players.length;
                    	players[len] = new Player(parseInt(message[i]),parseInt(message[i+1]), parseInt(message[i+2]),parseInt(message[i+3]),message[i+4]);
                    	players[len].show(); 
                	}    
            	}	
        	}

        }
        
        else if (message.startsWith("gameStateFood:")) {
            message = message.slice("gameStateBall:,".length);
            message = message.split(" ");
            log.innerHTML = '<li class="message">' + "gameStateFood:" + message + "</li>" + log.innerHTML;

            // Display food
            for( i = 0; i < message.length; i+=3) {    
                //Check if object already exists
                // \/ line belove doent work!
                if (foods.indexOf(message[i]) == -1) {
                    var len = foods.length;
                    var color = getRandomColor();
                    foods[len] = new Food(parseInt(message[i]),parseInt(message[i+1]), parseInt(message[i+2]), color);
                    foods[len].show(); //Display ball
                }
            }  

        }

        else if (message.startsWith("newPlayerBall:")) {
            message = message.slice("newPlayerBall:,".length);
            message = message.split(" ");
            log.innerHTML = '<li class="message">' + "newPlayerBall:" + message + "</li>" + log.innerHTML;
            player = new Player( parseInt(message[0]),  parseInt(message[1]),  parseInt(message[2]),  parseInt(message[3]),  message[4]); 

            deltaX = player.x_ - 399;
            deltaY = player.y_ - 399;

            gameBoardY = 2999;
            gameBoardX = 2999;


            player.show();
            gameLoop();

        }


        else if (message.startsWith("deleteBall:")) {
            message = message.slice("deleteBall:,".length);
            message = message.split(" ");
            log.innerHTML = '<li class="message">' + "deleteBall:" + message + "</li>" + log.innerHTML;
            var index = -1;

           	for (i in players) {
           		if (players[i].id_ == message[0]) index = i;
           	}	
           	
  			if (index != -1) players.splice(index,1);
  			reDrawCanvas();

        }

        else if (message.startsWith("deleteFood:")) {
            message = message.slice("deleteFood:,".length);
            message = message.split(" ");
            log.innerHTML = '<li class="message">' + "deleteFood:" + message + "</li>" + log.innerHTML;
        
            var index = -1;

           	for (i in foods) {
           		if (foods[i].id_ == message[0]) index = i;
           	}	
  			if (index != -1) foods.splice(index,1);
  			reDrawCanvas();

        }   

        else if (message.startsWith("ballUpdate:")) {
        	message = message.slice("ballUpdate:,".length);
            message = message.split(" ");
            
            var id = parseInt(message[0]);

            if (id != player.id_) {
            	for(i in players) {
            		if (players[i].id_ == id) {
            			players[i].x_ = parseInt(message[1]);
            			players[i].y_ = parseInt(message[2]);
            			players[i].r_ = parseInt(message[3]);
            		}
            	}
            }
            else if (id == player.id_) {
            	player.r_ = parseInt(message[3]);
            }
        }       
   
    }

    function sendPos() {

    	var message = "move:";
    	message += player.x_;
    	message += ",";
		message += player.y_
    	websocket.send(message);
    	//log.innerHTML = '<li class="message">' + message + "</li>" + log.innerHTML;

    }
    
    function getRandomColor() 
    {
        var letters = '0123456789ABCDEF';
        var color = '#';
        for (var i = 0; i < 6; i++ ) {
            color += letters[Math.floor(Math.random() * 16)];
        }
        return color;
    }
    
    function drawCircle(x_center,y_center,radius,color)
    {
        var start_angle = 0;
        var end_angle = 2*Math.PI;
        var c = document.getElementById("myCanvas");
        var ctx = c.getContext("2d");
        ctx.beginPath();    
        ctx.arc(x_center-deltaX,y_center-deltaY,radius,start_angle,end_angle);
		ctx.fillStyle = color;
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.stroke();
    }
    
    function onError(evt)
    { 
        state.className = "fail";
        state.innerHTML = "Communication error";
    }  

    function gameLoop() {

        raf = window.requestAnimationFrame(update);

    }

function getMousePos(canvas, evt) {
        var rect = canvas.getBoundingClientRect();
        return {
          x: evt.clientX - rect.left,
          y: evt.clientY - rect.top
        };
}

canvas.addEventListener('mousemove', function(evt) {
        mousePos = getMousePos(canvas, evt);
});

canvas.addEventListener('mouseover', function(e) {
  	raf = window.requestAnimationFrame(update);
});


canvas.addEventListener('mouseout', function(e) {
  window.cancelAnimationFrame(raf);
});

function reDrawCanvas() {

	

	for (var i in foods) {
		foods[i].show();
	}

	player.show();

	for (var i in players)
		players[i].show();

}

function reDrawGrid() {

context.fillStyle = "#F0FBFF";
context.strokeStyle = "BFBFBF";
context.lineWidth = 1;
constY = 150 - deltaY % 150;
constX = 150 - deltaX % 150;

//log.innerHTML = '<li class="message">' + deltaX + "</li>" + log.innerHTML;


for (i=0; i < 800; i += 150) {
	context.beginPath();
   	context.moveTo(0,constY + i);
   	context.lineTo(800,constY + i);
   	context.stroke();
 }


for (i=0; i < 800; i += 150) {
	context.beginPath();
  	context.moveTo(constX + i,0);
   	context.lineTo(constX + i,800);
   	context.stroke();
}


}





function update() {
 
	// Old movement 

	var dx = mousePos.x - 399;
  	var dy = mousePos.y - 399;
  	var v_len = Math.abs(Math.sqrt( (dy*dy) + (dx*dx) ));

  	var scaleX = Math.abs(dx / v_len);
  	var scaleY = Math.abs(dy / v_len);

  	//log.innerHTML = '<li class="message">' + scaleX + "</li>" + log.innerHTML;

  	if (mousePos.x > 400 && player.x_ < gameBoardX - boardMargin ) {
  		deltaX += scaleX *player.vx_;
  		player.x_ += scaleX * player.vx_;
  	}
  	else if (mousePos.x < 400 && player.x_ > 0 + boardMargin) {
  		deltaX -= scaleX * player.vx_;
  		player.x_ -= scaleX * player.vx_;
  	}
  	else {
		deltaX = deltaX;
  		player.x_ = player.x_;

  	}

  	if (mousePos.y > 400 && player.y_ < gameBoardY - boardMargin) {
  		deltaY += scaleY * player.vy_;
  		player.y_ += scaleY * player.vy_;

  	}
  	else if (mousePos.y < 400 && player.y_ > 0 + boardMargin) {
  		deltaY -= scaleY * player.vy_;
  		player.y_ -= scaleY * player.vy_;
  	}
  	else {
		deltaY = deltaY;
  		player.y_ = player.y_;

  	}

  	// New movement

  	//var sin = Math.sin((mousePos.x - player.x_ - deltaX)/(mousePos.y - player.y_ - deltaY));
  	//log.innerHTML = '<li class="message">' + mousePos.x + "</li>" + log.innerHTML;
  	//var temp = player.x_ - deltaX
  	//log.innerHTML = '<li class="message">' + temp + "</li>" + log.innerHTML;


	


  	
	context.clearRect(0,0,800,800);
	reDrawGrid();
	reDrawCanvas();
	sendPos();
	raf = window.requestAnimationFrame(update);
     
    
}


window.requestAnimFrame = (function() {
    return  window.requestAnimationFrame       ||
            window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame    ||
            window.msRequestAnimationFrame     ||
            function( callback ) {
                window.setTimeout(callback, 1000 / 60);
            };
})();

window.cancelAnimFrame = (function(handle) {
    return  window.cancelAnimationFrame     ||
            window.mozCancelAnimationFrame;
})();





















    
</script>
</section>
</body>
</html>